syntax = "proto3";
option java_multiple_files = true;
option java_package = "io.e6x.engine.grpc";

// REQUESTS AND RESPONSES //

message AuthenticateRequest
{
  string  user = 1;
  string  password = 2;
  optional string  userNameForImpersonation = 3;
}

// passing session IP as a session and session objects are local to planner
// session is per connection not per statement
// so to maintain stickiness in planner we will send session and the planner IP from which session is created
message AuthenticateResponse
{
  string  sessionId = 1;
  optional string new_strategy = 2;
  optional string engineIP = 3;
}

message IdentifyPlannerRequest
{
  string sessionId = 1;
  optional FirstTimeRequestPayload firstTimeRequestPayload = 2;
  optional ExistingQuery existingQuery = 3;

  message FirstTimeRequestPayload
  {
    string schema = 1;
    string catalog = 2;
    string queryString = 3;
  }
}

// This is exactly the same format as that of the thrift counter part
message IdentifyPlannerResponse
{
  enum QueueMessage
  {
    GO_AHEAD = 0;
    WAITING_ON_PLANNER_SCALEUP = 1;
    RATE_LIMIT = 2;
  }

  ExistingQuery existingQuery = 1;
  optional string plannerIp = 2;
  QueueMessage queueMessage = 3;
  string sessionId = 4;
}

message PrepareStatementRequest
{
  string sessionId = 1;
  string schema = 2;
  string queryString = 3;
  string quoting = 4;
  optional string plannerIp = 5;
  optional ExistingQuery existingQuery = 6;
}

message PrepareStatementV2Request
{
  string sessionId = 1;
  string schema = 2;
  string catalog = 3;
  string queryString = 4;
  string quoting = 5;
  optional string plannerIp = 6;
  optional ExistingQuery existingQuery = 7;
}

message PrepareStatementResponse
{
  string engineIP = 1;
  string queryId = 2;
  string sessionId = 3;
  optional string new_strategy = 4;
}

message ExecuteStatementRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
  bool shouldNotCache = 4;
}

message ExecuteStatementV2Request
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
  bool shouldNotCache = 4;
  repeated ParameterValue params = 5;
}

message ExecuteStatementResponse
{
  string sessionId = 1;
  optional string new_strategy = 2;
}

message GetResultMetadataRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
}

message GetResultMetadataResponse
{
  bytes resultMetaData = 1;
  string sessionId = 2;
  optional string new_strategy = 3;
}

message GetNextResultBatchRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
}

message GetNextResultBatchResponse
{
  bytes resultBatch = 2;
  string sessionId = 3;
  optional string new_strategy = 4;
}

message ExplainAnalyzeRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
}

message ExplainAnalyzeResponse
{
  string explainAnalyze = 1;
  bool isCached = 2;
  sint64 parsingTime = 3;
  sint64 queueingTime = 4;
  string sessionId = 5;
  optional string new_strategy = 6;
}

message ClearRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
}

message ClearResponse
{
  string sessionId = 1;
  optional string new_strategy = 2;
}

message CancelQueryRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
}

message CancelQueryResponse
{
  string sessionId = 1;
  optional string new_strategy = 2;
}

message ClearOrCancelQueryRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
  optional bool isDone = 4;
}

message ClearOrCancelQueryResponse
{
  string sessionId = 1;
  optional string new_strategy = 2;
}

message ExplainRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
}

message ExplainResponse
{
  string explain = 1;
  string sessionId = 2;
  optional string new_strategy = 3;
}

message AnalyzeQueryRequest
{
  string query = 1;
  string catalog = 2;
  string schema = 3;
}

message AnalyzeQueryResponse
{}

message StatusRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
}

message StatusResponse
{
  bool status = 2;
  sint64 rowCount = 3;
  string sessionId = 4;
  optional string new_strategy = 5;
}

message AddCatalogsRequest
{
  string sessionId = 1;
  string json = 2;
}

message AddCatalogsResponse
{
  string sessionId = 1;
}

message RefreshCatalogsRequest
{
  string sessionId = 1;
}

message RefreshCatalogsResponse
{
  string sessionId = 1;
}

message GetAddCatalogsRequest
{
  string sessionId = 1;
}

message GetAddCatalogsResponse
{
  string status = 1;
  repeated FailedSchemaElement failures = 2;
  string sessionId = 3;
}

message GetCatalogesRequest
{}

message GetCatalogesResponse
{
  repeated CatalogResponse catalogResponses = 1;
}

message GetSchemaNamesRequest
{
  string sessionId = 1;
}

message GetSchemaNamesV2Request
{
  string sessionId = 1;
  string catalog = 2;
}

message GetSchemaNamesResponse
{
  repeated string schemas = 1;
  string sessionId = 2;
  optional string new_strategy = 3;
}

message GetTablesRequest
{
  string sessionId = 1;
  string schema = 2;
}

message GetTablesV2Request
{
  string sessionId = 1;
  string schema = 2;
  string catalog = 3;
}

message GetTablesResponse
{
  repeated string tables = 1;
  string sessionId = 2;
  optional string new_strategy = 3;
}

message GetColumnsRequest
{
  string sessionId = 1;
  string schema = 2;
  string table = 3;
}
message GetColumnsV2Request
{
  string sessionId = 1;
  string schema = 2;
  string table = 3;
  string catalog = 4;
}

message GetColumnsResponse
{
  repeated GFieldInfo fieldInfo = 1;
  string sessionId = 2;
  optional string new_strategy = 3;
}

message UpdateUsersRequest
{
  bytes users = 1;
}

message UpdateUsersResponse
{}

message SetPropsRequest
{
  string sessionId = 1;
  string props = 2;
}

message SetPropsResponse
{}

message DryRunRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string schema = 3;
  string queryString = 4;
}

message DryRunRequestV2
{
  string engineIP = 1;
  string sessionId = 2;
  string schema = 3;
  string queryString = 4;
  string catalog = 5;
}

message DryRunResponse
{
  string dryrunValue = 1;
}

message RemoteChunkRequest
{
  string originalQueryId = 1;
  string remoteQueryId = 2;
  string sQueryHash = 3;
}

message RemoteChunkResponse
{
  string error = 1;
  bytes chunk = 2;
}

message GetDynamicParamsRequest
{
  string engineIP = 1;
  string sessionId = 2;
  string queryId = 3;
}

message GetDynamicParamsResponse
{
  repeated ParameterValue params = 1;
  string sessionId = 2;
}

// DATA HOLDERS //

message GFieldInfo
{
  string fieldName = 1;
  string fieldType = 2;
}

message FailedSchemaElement
{
  string name = 1;
  string type = 2;
  string reason = 3;
}

message CatalogResponse
{
  string name = 1;
  bool isDefault = 2;
}

message ParameterValue
{
  sint32 index = 1;
  string type = 2;
  string value = 3;
}

message UserAccessInfo
{
  string uuid = 1;
  string userName = 2;
  repeated string tokens = 3; // lIST
}

// This is needed to ensure backward compatibility [This has been introduced in context of query queuing for planning]
message ExistingQuery
{
  string queryId = 1;
  int64 elapsedTimeMillis = 2;
}

message SyncSchemaRequest
{
  string catalog = 1;
  string database = 2;
  string queryId = 3;
  bool isReplace = 4;
}

message SyncSchemaResponse
{

}

message HealthCheckRequest {}

message HealthCheckResponse {}

// DataFrame

message CreateDataFrameRequest
{
  string parquetFilePath = 1;
  string catalog = 2;
  string schema = 3;
  string table = 4;
  string sessionId = 5;
  string engineIP = 6;
  int32 dataframeNumber = 7;
  bool createFromParquet = 8;
}

message CreateDataFrameResponse
{
  string queryId = 1;
}

message ProjectionOnDataFrameRequest
{
  string queryId = 1;
  int32 dataframeNumber = 2;
  string sessionId = 3;
  string engineIP = 4;
  repeated string field = 5;
}

message ProjectionOnDataFrameResponse {}

message AggregateOnDataFrameRequest
{
  string queryId = 1;
  int32 dataframeNumber = 2;
  string sessionId = 3;
  string engineIP = 4;
  map<string, AggregateFunction> aggregateFunctionMap = 5;
  repeated string groupBy = 6;
}

enum AggregateFunction
{
  SUM = 0;
  COUNT = 1;
  COUNT_STAR = 2;
  COUNT_DISTINCT = 3;
}

message AggregateOnDataFrameResponse {}

message FilterOnDataFrameRequest
{
  string queryId = 1;
  int32 dataframeNumber = 2;
  string sessionId = 3;
  string engineIP = 4;
  string whereClause = 5;
}

message FilterOnDataFrameResponse {}

enum SortDirection
{
  ASC = 0;
  DESC = 1;
}

message OrderByOnDataFrameRequest
{
  string queryId = 1;
  int32 dataframeNumber = 2;
  string sessionId = 3;
  string engineIP = 4;
  map<string, SortDirection> orderByFieldMap = 5;
}

message OrderByOnDataFrameResponse {}

message LimitOnDataFrameRequest
{
  string queryId = 1;
  int32 dataframeNumber = 2;
  string sessionId = 3;
  string engineIP = 4;
  int32 fetchLimit = 5;
}

message LimitOnDataFrameResponse {}

message ExecuteDataFrameRequest
{
  string queryId = 1;
  int32 dataframeNumber = 2;
  string sessionId = 3;
  string engineIP = 4;
}

message ExecuteDataFrameResponse {}

message DropUserContextRequest
{
    string sessionId = 1;
    string engineIP = 2;
}

message DropUserContextResponse {}

service QueryEngineService
{

  // Client sided API

  rpc authenticate(AuthenticateRequest) returns (AuthenticateResponse);

  rpc identifyPlanner(IdentifyPlannerRequest) returns (IdentifyPlannerResponse); // This is a stateless call

  rpc prepareStatement(PrepareStatementRequest) returns (PrepareStatementResponse);

  rpc prepareStatementV2(PrepareStatementV2Request) returns (PrepareStatementResponse);

  rpc executeStatement(ExecuteStatementRequest) returns (ExecuteStatementResponse);

  rpc executeStatementV2(ExecuteStatementV2Request) returns (ExecuteStatementResponse);

  rpc getResultMetadata(GetResultMetadataRequest) returns (GetResultMetadataResponse);

  rpc getDynamicParams(GetDynamicParamsRequest) returns (GetDynamicParamsResponse);

  rpc getNextResultBatch(GetNextResultBatchRequest) returns (GetNextResultBatchResponse);

  rpc explainAnalyze(ExplainAnalyzeRequest) returns (ExplainAnalyzeResponse);

  rpc clear(ClearRequest) returns (ClearResponse);

  rpc cancelQuery(CancelQueryRequest) returns (CancelQueryResponse);

  rpc clearOrCancelQuery(ClearOrCancelQueryRequest) returns (ClearOrCancelQueryResponse);

  rpc syncSchemas(SyncSchemaRequest) returns (SyncSchemaResponse);

  // Platform sided API

  rpc healthCheck(HealthCheckRequest) returns (HealthCheckResponse);

  rpc analyzeQuery(AnalyzeQueryRequest) returns (AnalyzeQueryResponse);

  rpc explain(ExplainRequest) returns (ExplainResponse);

  rpc status(StatusRequest) returns (StatusResponse);

  rpc addCatalogs(AddCatalogsRequest) returns (AddCatalogsResponse);

  rpc refreshCatalogs(RefreshCatalogsRequest) returns (RefreshCatalogsResponse);

  rpc getAddCatalogsResponse(GetAddCatalogsRequest) returns (GetAddCatalogsResponse);

  rpc getCataloges(GetCatalogesRequest) returns (GetCatalogesResponse);

  rpc getSchemaNames(GetSchemaNamesRequest) returns (GetSchemaNamesResponse);

  rpc getSchemaNamesV2(GetSchemaNamesV2Request) returns (GetSchemaNamesResponse);

  rpc getTables(GetTablesRequest) returns (GetTablesResponse);

  rpc getTablesV2(GetTablesV2Request) returns (GetTablesResponse);

  rpc getColumns(GetColumnsRequest) returns (GetColumnsResponse);

  rpc getColumnsV2(GetColumnsV2Request) returns (GetColumnsResponse);

  rpc updateUsers(UpdateUsersRequest) returns (UpdateUsersResponse);

  rpc setProps(SetPropsRequest) returns (SetPropsResponse);

  // Not implemented / Not in use / Deprecated

  rpc dryRun(DryRunRequest) returns (DryRunResponse); // Executor, Engine

  rpc dryRunV2(DryRunRequestV2) returns (DryRunResponse);

  rpc getNextRemoteCachedChunk(RemoteChunkRequest) returns (RemoteChunkResponse);

  // dataframe

  rpc createDataFrame(CreateDataFrameRequest) returns (CreateDataFrameResponse);

  rpc projectionOnDataFrame(ProjectionOnDataFrameRequest) returns (ProjectionOnDataFrameResponse);

  rpc aggregateOnDataFrame(AggregateOnDataFrameRequest) returns (AggregateOnDataFrameResponse);

  rpc filterOnDataFrame(FilterOnDataFrameRequest) returns (FilterOnDataFrameResponse);

  rpc orderByOnDataFrame(OrderByOnDataFrameRequest) returns (OrderByOnDataFrameResponse);

  rpc limitOnDataFrame(LimitOnDataFrameRequest) returns (LimitOnDataFrameResponse);

  rpc executeDataFrame(ExecuteDataFrameRequest) returns (ExecuteDataFrameResponse);

  rpc dropUserContext(DropUserContextRequest) returns (DropUserContextResponse);

}