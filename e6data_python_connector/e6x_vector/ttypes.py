#
# Autogenerated by Thrift Compiler (0.21.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys

from thrift.transport import TTransport
all_structs = []


class VectorType(object):
    BINARY = 0
    BOOLEAN = 1
    DOUBLE = 2
    FLOAT = 3
    INT96 = 4
    INTEGER = 5
    LONG = 6
    STRING = 7
    DATE = 8
    DATETIME = 9
    TIMESTAMP = 10
    STRUCT = 11
    MAP = 12
    ARRAY = 13
    NULL = 14
    TIMESTAMP_TZ = 15
    DECIMAL128 = 16

    _VALUES_TO_NAMES = {
        0: "BINARY",
        1: "BOOLEAN",
        2: "DOUBLE",
        3: "FLOAT",
        4: "INT96",
        5: "INTEGER",
        6: "LONG",
        7: "STRING",
        8: "DATE",
        9: "DATETIME",
        10: "TIMESTAMP",
        11: "STRUCT",
        12: "MAP",
        13: "ARRAY",
        14: "NULL",
        15: "TIMESTAMP_TZ",
        16: "DECIMAL128",
    }

    _NAMES_TO_VALUES = {
        "BINARY": 0,
        "BOOLEAN": 1,
        "DOUBLE": 2,
        "FLOAT": 3,
        "INT96": 4,
        "INTEGER": 5,
        "LONG": 6,
        "STRING": 7,
        "DATE": 8,
        "DATETIME": 9,
        "TIMESTAMP": 10,
        "STRUCT": 11,
        "MAP": 12,
        "ARRAY": 13,
        "NULL": 14,
        "TIMESTAMP_TZ": 15,
        "DECIMAL128": 16,
    }


class Vector(object):
    """
    Attributes:
     - size
     - vectorType
     - nullSet
     - data
     - isConstantVector
     - zoneOffset
     - format

    """
    thrift_spec = None


    def __init__(self, size = None, vectorType = None, nullSet = None, data = None, isConstantVector = None, zoneOffset = None, format = None,):
        self.size = size
        self.vectorType = vectorType
        self.nullSet = nullSet
        self.data = data
        self.isConstantVector = isConstantVector
        self.zoneOffset = zoneOffset
        self.format = format

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.vectorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.nullSet = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readBool()
                        self.nullSet.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.data = Data()
                    self.data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isConstantVector = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.zoneOffset = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.format = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Vector')
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 1)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.vectorType is not None:
            oprot.writeFieldBegin('vectorType', TType.I32, 2)
            oprot.writeI32(self.vectorType)
            oprot.writeFieldEnd()
        if self.nullSet is not None:
            oprot.writeFieldBegin('nullSet', TType.LIST, 3)
            oprot.writeListBegin(TType.BOOL, len(self.nullSet))
            for iter6 in self.nullSet:
                oprot.writeBool(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRUCT, 4)
            self.data.write(oprot)
            oprot.writeFieldEnd()
        if self.isConstantVector is not None:
            oprot.writeFieldBegin('isConstantVector', TType.BOOL, 5)
            oprot.writeBool(self.isConstantVector)
            oprot.writeFieldEnd()
        if self.zoneOffset is not None:
            oprot.writeFieldBegin('zoneOffset', TType.STRING, 6)
            oprot.writeString(self.zoneOffset.encode('utf-8') if sys.version_info[0] == 2 else self.zoneOffset)
            oprot.writeFieldEnd()
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.STRING, 7)
            oprot.writeString(self.format.encode('utf-8') if sys.version_info[0] == 2 else self.format)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Data(object):
    """
    Attributes:
     - boolData
     - int32Data
     - int64Data
     - dateData
     - float32Data
     - float64Data
     - varcharData
     - boolConstantData
     - dateConstantData
     - nullConstantData
     - numericConstantData
     - numericDecimalConstantData
     - temporalIntervalConstantData
     - timeConstantData
     - varcharConstantData
     - timeData
     - decimal128Data
     - numericDecimal128ConstantData

    """
    thrift_spec = None


    def __init__(self, boolData = None, int32Data = None, int64Data = None, dateData = None, float32Data = None, float64Data = None, varcharData = None, boolConstantData = None, dateConstantData = None, nullConstantData = None, numericConstantData = None, numericDecimalConstantData = None, temporalIntervalConstantData = None, timeConstantData = None, varcharConstantData = None, timeData = None, decimal128Data = None, numericDecimal128ConstantData = None,):
        self.boolData = boolData
        self.int32Data = int32Data
        self.int64Data = int64Data
        self.dateData = dateData
        self.float32Data = float32Data
        self.float64Data = float64Data
        self.varcharData = varcharData
        self.boolConstantData = boolConstantData
        self.dateConstantData = dateConstantData
        self.nullConstantData = nullConstantData
        self.numericConstantData = numericConstantData
        self.numericDecimalConstantData = numericDecimalConstantData
        self.temporalIntervalConstantData = temporalIntervalConstantData
        self.timeConstantData = timeConstantData
        self.varcharConstantData = varcharConstantData
        self.timeData = timeData
        self.decimal128Data = decimal128Data
        self.numericDecimal128ConstantData = numericDecimal128ConstantData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.boolData = BoolData()
                    self.boolData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.int32Data = Int32Data()
                    self.int32Data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.int64Data = Int64Data()
                    self.int64Data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.dateData = DateData()
                    self.dateData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.float32Data = Float32Data()
                    self.float32Data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.float64Data = Float64Data()
                    self.float64Data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.varcharData = VarcharData()
                    self.varcharData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.boolConstantData = BoolConstantData()
                    self.boolConstantData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.dateConstantData = DateConstantData()
                    self.dateConstantData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.nullConstantData = NullConstantData()
                    self.nullConstantData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.numericConstantData = NumericConstantData()
                    self.numericConstantData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.numericDecimalConstantData = NumericDecimalConstantData()
                    self.numericDecimalConstantData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.temporalIntervalConstantData = TemporalIntervalConstantData()
                    self.temporalIntervalConstantData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.timeConstantData = TimeConstantData()
                    self.timeConstantData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.varcharConstantData = VarcharConstantData()
                    self.varcharConstantData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.timeData = TimeData()
                    self.timeData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.decimal128Data = Decimal128Data()
                    self.decimal128Data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.numericDecimal128ConstantData = NumericDecimal128ConstantData()
                    self.numericDecimal128ConstantData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Data')
        if self.boolData is not None:
            oprot.writeFieldBegin('boolData', TType.STRUCT, 1)
            self.boolData.write(oprot)
            oprot.writeFieldEnd()
        if self.int32Data is not None:
            oprot.writeFieldBegin('int32Data', TType.STRUCT, 2)
            self.int32Data.write(oprot)
            oprot.writeFieldEnd()
        if self.int64Data is not None:
            oprot.writeFieldBegin('int64Data', TType.STRUCT, 3)
            self.int64Data.write(oprot)
            oprot.writeFieldEnd()
        if self.dateData is not None:
            oprot.writeFieldBegin('dateData', TType.STRUCT, 4)
            self.dateData.write(oprot)
            oprot.writeFieldEnd()
        if self.float32Data is not None:
            oprot.writeFieldBegin('float32Data', TType.STRUCT, 5)
            self.float32Data.write(oprot)
            oprot.writeFieldEnd()
        if self.float64Data is not None:
            oprot.writeFieldBegin('float64Data', TType.STRUCT, 6)
            self.float64Data.write(oprot)
            oprot.writeFieldEnd()
        if self.varcharData is not None:
            oprot.writeFieldBegin('varcharData', TType.STRUCT, 7)
            self.varcharData.write(oprot)
            oprot.writeFieldEnd()
        if self.boolConstantData is not None:
            oprot.writeFieldBegin('boolConstantData', TType.STRUCT, 8)
            self.boolConstantData.write(oprot)
            oprot.writeFieldEnd()
        if self.dateConstantData is not None:
            oprot.writeFieldBegin('dateConstantData', TType.STRUCT, 9)
            self.dateConstantData.write(oprot)
            oprot.writeFieldEnd()
        if self.nullConstantData is not None:
            oprot.writeFieldBegin('nullConstantData', TType.STRUCT, 10)
            self.nullConstantData.write(oprot)
            oprot.writeFieldEnd()
        if self.numericConstantData is not None:
            oprot.writeFieldBegin('numericConstantData', TType.STRUCT, 11)
            self.numericConstantData.write(oprot)
            oprot.writeFieldEnd()
        if self.numericDecimalConstantData is not None:
            oprot.writeFieldBegin('numericDecimalConstantData', TType.STRUCT, 12)
            self.numericDecimalConstantData.write(oprot)
            oprot.writeFieldEnd()
        if self.temporalIntervalConstantData is not None:
            oprot.writeFieldBegin('temporalIntervalConstantData', TType.STRUCT, 13)
            self.temporalIntervalConstantData.write(oprot)
            oprot.writeFieldEnd()
        if self.timeConstantData is not None:
            oprot.writeFieldBegin('timeConstantData', TType.STRUCT, 14)
            self.timeConstantData.write(oprot)
            oprot.writeFieldEnd()
        if self.varcharConstantData is not None:
            oprot.writeFieldBegin('varcharConstantData', TType.STRUCT, 15)
            self.varcharConstantData.write(oprot)
            oprot.writeFieldEnd()
        if self.timeData is not None:
            oprot.writeFieldBegin('timeData', TType.STRUCT, 16)
            self.timeData.write(oprot)
            oprot.writeFieldEnd()
        if self.decimal128Data is not None:
            oprot.writeFieldBegin('decimal128Data', TType.STRUCT, 17)
            self.decimal128Data.write(oprot)
            oprot.writeFieldEnd()
        if self.numericDecimal128ConstantData is not None:
            oprot.writeFieldBegin('numericDecimal128ConstantData', TType.STRUCT, 18)
            self.numericDecimal128ConstantData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BoolData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readBool()
                        self.data.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BoolData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BOOL, len(self.data))
            for iter13 in self.data:
                oprot.writeBool(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Int32Data(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readI32()
                        self.data.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Int32Data')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.data))
            for iter20 in self.data:
                oprot.writeI32(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Int64Data(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI64()
                        self.data.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Int64Data')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.data))
            for iter27 in self.data:
                oprot.writeI64(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DateData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readI64()
                        self.data.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DateData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.data))
            for iter34 in self.data:
                oprot.writeI64(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Float32Data(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readDouble()
                        self.data.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Float32Data')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.data))
            for iter41 in self.data:
                oprot.writeDouble(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Float64Data(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readDouble()
                        self.data.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Float64Data')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.data))
            for iter48 in self.data:
                oprot.writeDouble(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Decimal128Data(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readBinary()
                        self.data.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Decimal128Data')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.data))
            for iter55 in self.data:
                oprot.writeBinary(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VarcharData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.data.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VarcharData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.data))
            for iter62 in self.data:
                oprot.writeString(iter62.encode('utf-8') if sys.version_info[0] == 2 else iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BoolConstantData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.data = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BoolConstantData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.BOOL, 1)
            oprot.writeBool(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DateConstantData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.data = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DateConstantData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.I64, 1)
            oprot.writeI64(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NullConstantData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.data = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NullConstantData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.BYTE, 1)
            oprot.writeByte(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NumericConstantData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.data = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NumericConstantData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.I64, 1)
            oprot.writeI64(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NumericDecimalConstantData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.data = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NumericDecimalConstantData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.DOUBLE, 1)
            oprot.writeDouble(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NumericDecimal128ConstantData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NumericDecimal128ConstantData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TemporalIntervalConstantData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.data = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TemporalIntervalConstantData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.BYTE, 1)
            oprot.writeByte(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TimeConstantData(object):
    """
    Attributes:
     - data
     - zoneData

    """
    thrift_spec = None


    def __init__(self, data = None, zoneData = None,):
        self.data = data
        self.zoneData = zoneData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.data = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.zoneData = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TimeConstantData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.I64, 1)
            oprot.writeI64(self.data)
            oprot.writeFieldEnd()
        if self.zoneData is not None:
            oprot.writeFieldBegin('zoneData', TType.STRING, 2)
            oprot.writeString(self.zoneData.encode('utf-8') if sys.version_info[0] == 2 else self.zoneData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VarcharConstantData(object):
    """
    Attributes:
     - data

    """
    thrift_spec = None


    def __init__(self, data = None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VarcharConstantData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 1)
            oprot.writeString(self.data.encode('utf-8') if sys.version_info[0] == 2 else self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TimeData(object):
    """
    Attributes:
     - data
     - zoneData

    """
    thrift_spec = None


    def __init__(self, data = None, zoneData = None,):
        self.data = data
        self.zoneData = zoneData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = iprot.readI64()
                        self.data.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.zoneData = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.zoneData.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TimeData')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.data))
            for iter75 in self.data:
                oprot.writeI64(iter75)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.zoneData is not None:
            oprot.writeFieldBegin('zoneData', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.zoneData))
            for iter76 in self.zoneData:
                oprot.writeString(iter76.encode('utf-8') if sys.version_info[0] == 2 else iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Chunk(object):
    """
    Attributes:
     - size
     - vectors

    """
    thrift_spec = None


    def __init__(self, size = None, vectors = None,):
        self.size = size
        self.vectors = vectors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.vectors = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = Vector()
                        _elem82.read(iprot)
                        self.vectors.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Chunk')
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 1)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.vectors is not None:
            oprot.writeFieldBegin('vectors', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.vectors))
            for iter83 in self.vectors:
                iter83.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Vector)
Vector.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'size', None, None, ),  # 1
    (2, TType.I32, 'vectorType', None, None, ),  # 2
    (3, TType.LIST, 'nullSet', (TType.BOOL, None, False), None, ),  # 3
    (4, TType.STRUCT, 'data', [Data, None], None, ),  # 4
    (5, TType.BOOL, 'isConstantVector', None, None, ),  # 5
    (6, TType.STRING, 'zoneOffset', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'format', 'UTF8', None, ),  # 7
)
all_structs.append(Data)
Data.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'boolData', [BoolData, None], None, ),  # 1
    (2, TType.STRUCT, 'int32Data', [Int32Data, None], None, ),  # 2
    (3, TType.STRUCT, 'int64Data', [Int64Data, None], None, ),  # 3
    (4, TType.STRUCT, 'dateData', [DateData, None], None, ),  # 4
    (5, TType.STRUCT, 'float32Data', [Float32Data, None], None, ),  # 5
    (6, TType.STRUCT, 'float64Data', [Float64Data, None], None, ),  # 6
    (7, TType.STRUCT, 'varcharData', [VarcharData, None], None, ),  # 7
    (8, TType.STRUCT, 'boolConstantData', [BoolConstantData, None], None, ),  # 8
    (9, TType.STRUCT, 'dateConstantData', [DateConstantData, None], None, ),  # 9
    (10, TType.STRUCT, 'nullConstantData', [NullConstantData, None], None, ),  # 10
    (11, TType.STRUCT, 'numericConstantData', [NumericConstantData, None], None, ),  # 11
    (12, TType.STRUCT, 'numericDecimalConstantData', [NumericDecimalConstantData, None], None, ),  # 12
    (13, TType.STRUCT, 'temporalIntervalConstantData', [TemporalIntervalConstantData, None], None, ),  # 13
    (14, TType.STRUCT, 'timeConstantData', [TimeConstantData, None], None, ),  # 14
    (15, TType.STRUCT, 'varcharConstantData', [VarcharConstantData, None], None, ),  # 15
    (16, TType.STRUCT, 'timeData', [TimeData, None], None, ),  # 16
    (17, TType.STRUCT, 'decimal128Data', [Decimal128Data, None], None, ),  # 17
    (18, TType.STRUCT, 'numericDecimal128ConstantData', [NumericDecimal128ConstantData, None], None, ),  # 18
)
all_structs.append(BoolData)
BoolData.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BOOL, None, False), None, ),  # 1
)
all_structs.append(Int32Data)
Int32Data.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.I32, None, False), None, ),  # 1
)
all_structs.append(Int64Data)
Int64Data.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.I64, None, False), None, ),  # 1
)
all_structs.append(DateData)
DateData.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.I64, None, False), None, ),  # 1
)
all_structs.append(Float32Data)
Float32Data.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.DOUBLE, None, False), None, ),  # 1
)
all_structs.append(Float64Data)
Float64Data.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.DOUBLE, None, False), None, ),  # 1
)
all_structs.append(Decimal128Data)
Decimal128Data.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.STRING, 'BINARY', False), None, ),  # 1
)
all_structs.append(VarcharData)
VarcharData.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(BoolConstantData)
BoolConstantData.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'data', None, None, ),  # 1
)
all_structs.append(DateConstantData)
DateConstantData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'data', None, None, ),  # 1
)
all_structs.append(NullConstantData)
NullConstantData.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'data', None, None, ),  # 1
)
all_structs.append(NumericConstantData)
NumericConstantData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'data', None, None, ),  # 1
)
all_structs.append(NumericDecimalConstantData)
NumericDecimalConstantData.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'data', None, None, ),  # 1
)
all_structs.append(NumericDecimal128ConstantData)
NumericDecimal128ConstantData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'BINARY', None, ),  # 1
)
all_structs.append(TemporalIntervalConstantData)
TemporalIntervalConstantData.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'data', None, None, ),  # 1
)
all_structs.append(TimeConstantData)
TimeConstantData.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'data', None, None, ),  # 1
    (2, TType.STRING, 'zoneData', 'UTF8', None, ),  # 2
)
all_structs.append(VarcharConstantData)
VarcharConstantData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data', 'UTF8', None, ),  # 1
)
all_structs.append(TimeData)
TimeData.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.I64, None, False), None, ),  # 1
    (2, TType.LIST, 'zoneData', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(Chunk)
Chunk.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'size', None, None, ),  # 1
    (2, TType.LIST, 'vectors', (TType.STRUCT, [Vector, None], False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
