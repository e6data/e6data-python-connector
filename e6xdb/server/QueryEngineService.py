#
# Autogenerated by Thrift Compiler (0.17.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def clear(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        pass

    def cancelQuery(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        pass

    def explain(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        pass

    def dryRun(self, sessionId, sSchema, sQueryString):
        """
        Parameters:
         - sessionId
         - sSchema
         - sQueryString

        """
        pass

    def explainAnalyze(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        pass

    def prepareStatement(self, sessionId, sSchemaName, query):
        """
        Parameters:
         - sessionId
         - sSchemaName
         - query

        """
        pass

    def executeStatement(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        pass

    def getNextResultRow(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        pass

    def getNextResultBatch(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        pass

    def getResultMetadata(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        pass

    def authenticate(self, user, password):
        """
        Parameters:
         - user
         - password

        """
        pass

    def getTables(self, sessionId, schema):
        """
        Parameters:
         - sessionId
         - schema

        """
        pass

    def getSchemaNames(self, sessionId):
        """
        Parameters:
         - sessionId

        """
        pass

    def getColumns(self, sessionId, schema, table):
        """
        Parameters:
         - sessionId
         - schema
         - table

        """
        pass

    def updateUsers(self, userInfo):
        """
        Parameters:
         - userInfo

        """
        pass

    def setProps(self, sessionId, propMap):
        """
        Parameters:
         - sessionId
         - propMap

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def clear(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        self.send_clear(sessionId, queryId)
        self.recv_clear()

    def send_clear(self, sessionId, queryId):
        self._oprot.writeMessageBegin('clear', TMessageType.CALL, self._seqid)
        args = clear_args()
        args.sessionId = sessionId
        args.queryId = queryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clear(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clear_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        return

    def cancelQuery(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        self.send_cancelQuery(sessionId, queryId)
        self.recv_cancelQuery()

    def send_cancelQuery(self, sessionId, queryId):
        self._oprot.writeMessageBegin('cancelQuery', TMessageType.CALL, self._seqid)
        args = cancelQuery_args()
        args.sessionId = sessionId
        args.queryId = queryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancelQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancelQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        return

    def explain(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        self.send_explain(sessionId, queryId)
        return self.recv_explain()

    def send_explain(self, sessionId, queryId):
        self._oprot.writeMessageBegin('explain', TMessageType.CALL, self._seqid)
        args = explain_args()
        args.sessionId = sessionId
        args.queryId = queryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_explain(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = explain_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "explain failed: unknown result")

    def dryRun(self, sessionId, sSchema, sQueryString):
        """
        Parameters:
         - sessionId
         - sSchema
         - sQueryString

        """
        self.send_dryRun(sessionId, sSchema, sQueryString)
        return self.recv_dryRun()

    def send_dryRun(self, sessionId, sSchema, sQueryString):
        self._oprot.writeMessageBegin('dryRun', TMessageType.CALL, self._seqid)
        args = dryRun_args()
        args.sessionId = sessionId
        args.sSchema = sSchema
        args.sQueryString = sQueryString
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dryRun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dryRun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dryRun failed: unknown result")

    def explainAnalyze(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        self.send_explainAnalyze(sessionId, queryId)
        return self.recv_explainAnalyze()

    def send_explainAnalyze(self, sessionId, queryId):
        self._oprot.writeMessageBegin('explainAnalyze', TMessageType.CALL, self._seqid)
        args = explainAnalyze_args()
        args.sessionId = sessionId
        args.queryId = queryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_explainAnalyze(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = explainAnalyze_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "explainAnalyze failed: unknown result")

    def prepareStatement(self, sessionId, sSchemaName, query):
        """
        Parameters:
         - sessionId
         - sSchemaName
         - query

        """
        self.send_prepareStatement(sessionId, sSchemaName, query)
        return self.recv_prepareStatement()

    def send_prepareStatement(self, sessionId, sSchemaName, query):
        self._oprot.writeMessageBegin('prepareStatement', TMessageType.CALL, self._seqid)
        args = prepareStatement_args()
        args.sessionId = sessionId
        args.sSchemaName = sSchemaName
        args.query = query
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_prepareStatement(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = prepareStatement_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "prepareStatement failed: unknown result")

    def executeStatement(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        self.send_executeStatement(sessionId, queryId)
        self.recv_executeStatement()

    def send_executeStatement(self, sessionId, queryId):
        self._oprot.writeMessageBegin('executeStatement', TMessageType.CALL, self._seqid)
        args = executeStatement_args()
        args.sessionId = sessionId
        args.queryId = queryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executeStatement(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executeStatement_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        return

    def getNextResultRow(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        self.send_getNextResultRow(sessionId, queryId)
        return self.recv_getNextResultRow()

    def send_getNextResultRow(self, sessionId, queryId):
        self._oprot.writeMessageBegin('getNextResultRow', TMessageType.CALL, self._seqid)
        args = getNextResultRow_args()
        args.sessionId = sessionId
        args.queryId = queryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNextResultRow(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNextResultRow_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNextResultRow failed: unknown result")

    def getNextResultBatch(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        self.send_getNextResultBatch(sessionId, queryId)
        return self.recv_getNextResultBatch()

    def send_getNextResultBatch(self, sessionId, queryId):
        self._oprot.writeMessageBegin('getNextResultBatch', TMessageType.CALL, self._seqid)
        args = getNextResultBatch_args()
        args.sessionId = sessionId
        args.queryId = queryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNextResultBatch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNextResultBatch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNextResultBatch failed: unknown result")

    def getResultMetadata(self, sessionId, queryId):
        """
        Parameters:
         - sessionId
         - queryId

        """
        self.send_getResultMetadata(sessionId, queryId)
        return self.recv_getResultMetadata()

    def send_getResultMetadata(self, sessionId, queryId):
        self._oprot.writeMessageBegin('getResultMetadata', TMessageType.CALL, self._seqid)
        args = getResultMetadata_args()
        args.sessionId = sessionId
        args.queryId = queryId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getResultMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getResultMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getResultMetadata failed: unknown result")

    def authenticate(self, user, password):
        """
        Parameters:
         - user
         - password

        """
        self.send_authenticate(user, password)
        return self.recv_authenticate()

    def send_authenticate(self, user, password):
        self._oprot.writeMessageBegin('authenticate', TMessageType.CALL, self._seqid)
        args = authenticate_args()
        args.user = user
        args.password = password
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_authenticate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = authenticate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticate failed: unknown result")

    def getTables(self, sessionId, schema):
        """
        Parameters:
         - sessionId
         - schema

        """
        self.send_getTables(sessionId, schema)
        return self.recv_getTables()

    def send_getTables(self, sessionId, schema):
        self._oprot.writeMessageBegin('getTables', TMessageType.CALL, self._seqid)
        args = getTables_args()
        args.sessionId = sessionId
        args.schema = schema
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTables failed: unknown result")

    def getSchemaNames(self, sessionId):
        """
        Parameters:
         - sessionId

        """
        self.send_getSchemaNames(sessionId)
        return self.recv_getSchemaNames()

    def send_getSchemaNames(self, sessionId):
        self._oprot.writeMessageBegin('getSchemaNames', TMessageType.CALL, self._seqid)
        args = getSchemaNames_args()
        args.sessionId = sessionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSchemaNames(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSchemaNames_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSchemaNames failed: unknown result")

    def getColumns(self, sessionId, schema, table):
        """
        Parameters:
         - sessionId
         - schema
         - table

        """
        self.send_getColumns(sessionId, schema, table)
        return self.recv_getColumns()

    def send_getColumns(self, sessionId, schema, table):
        self._oprot.writeMessageBegin('getColumns', TMessageType.CALL, self._seqid)
        args = getColumns_args()
        args.sessionId = sessionId
        args.schema = schema
        args.table = table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getColumns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getColumns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getColumns failed: unknown result")

    def updateUsers(self, userInfo):
        """
        Parameters:
         - userInfo

        """
        self.send_updateUsers(userInfo)
        self.recv_updateUsers()

    def send_updateUsers(self, userInfo):
        self._oprot.writeMessageBegin('updateUsers', TMessageType.CALL, self._seqid)
        args = updateUsers_args()
        args.userInfo = userInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateUsers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateUsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error1 is not None:
            raise result.error1
        if result.error2 is not None:
            raise result.error2
        return

    def setProps(self, sessionId, propMap):
        """
        Parameters:
         - sessionId
         - propMap

        """
        self.send_setProps(sessionId, propMap)
        self.recv_setProps()

    def send_setProps(self, sessionId, propMap):
        self._oprot.writeMessageBegin('setProps', TMessageType.CALL, self._seqid)
        args = setProps_args()
        args.sessionId = sessionId
        args.propMap = propMap
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setProps(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setProps_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error2 is not None:
            raise result.error2
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["clear"] = Processor.process_clear
        self._processMap["cancelQuery"] = Processor.process_cancelQuery
        self._processMap["explain"] = Processor.process_explain
        self._processMap["dryRun"] = Processor.process_dryRun
        self._processMap["explainAnalyze"] = Processor.process_explainAnalyze
        self._processMap["prepareStatement"] = Processor.process_prepareStatement
        self._processMap["executeStatement"] = Processor.process_executeStatement
        self._processMap["getNextResultRow"] = Processor.process_getNextResultRow
        self._processMap["getNextResultBatch"] = Processor.process_getNextResultBatch
        self._processMap["getResultMetadata"] = Processor.process_getResultMetadata
        self._processMap["authenticate"] = Processor.process_authenticate
        self._processMap["getTables"] = Processor.process_getTables
        self._processMap["getSchemaNames"] = Processor.process_getSchemaNames
        self._processMap["getColumns"] = Processor.process_getColumns
        self._processMap["updateUsers"] = Processor.process_updateUsers
        self._processMap["setProps"] = Processor.process_setProps
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_clear(self, seqid, iprot, oprot):
        args = clear_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clear_result()
        try:
            self._handler.clear(args.sessionId, args.queryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clear", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancelQuery(self, seqid, iprot, oprot):
        args = cancelQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancelQuery_result()
        try:
            self._handler.cancelQuery(args.sessionId, args.queryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancelQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_explain(self, seqid, iprot, oprot):
        args = explain_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = explain_result()
        try:
            result.success = self._handler.explain(args.sessionId, args.queryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("explain", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dryRun(self, seqid, iprot, oprot):
        args = dryRun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dryRun_result()
        try:
            result.success = self._handler.dryRun(args.sessionId, args.sSchema, args.sQueryString)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dryRun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_explainAnalyze(self, seqid, iprot, oprot):
        args = explainAnalyze_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = explainAnalyze_result()
        try:
            result.success = self._handler.explainAnalyze(args.sessionId, args.queryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("explainAnalyze", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_prepareStatement(self, seqid, iprot, oprot):
        args = prepareStatement_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = prepareStatement_result()
        try:
            result.success = self._handler.prepareStatement(args.sessionId, args.sSchemaName, args.query)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("prepareStatement", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executeStatement(self, seqid, iprot, oprot):
        args = executeStatement_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executeStatement_result()
        try:
            self._handler.executeStatement(args.sessionId, args.queryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executeStatement", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNextResultRow(self, seqid, iprot, oprot):
        args = getNextResultRow_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNextResultRow_result()
        try:
            result.success = self._handler.getNextResultRow(args.sessionId, args.queryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNextResultRow", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNextResultBatch(self, seqid, iprot, oprot):
        args = getNextResultBatch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNextResultBatch_result()
        try:
            result.success = self._handler.getNextResultBatch(args.sessionId, args.queryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNextResultBatch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getResultMetadata(self, seqid, iprot, oprot):
        args = getResultMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getResultMetadata_result()
        try:
            result.success = self._handler.getResultMetadata(args.sessionId, args.queryId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getResultMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_authenticate(self, seqid, iprot, oprot):
        args = authenticate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = authenticate_result()
        try:
            result.success = self._handler.authenticate(args.user, args.password)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccessDeniedException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("authenticate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTables(self, seqid, iprot, oprot):
        args = getTables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTables_result()
        try:
            result.success = self._handler.getTables(args.sessionId, args.schema)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSchemaNames(self, seqid, iprot, oprot):
        args = getSchemaNames_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSchemaNames_result()
        try:
            result.success = self._handler.getSchemaNames(args.sessionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSchemaNames", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getColumns(self, seqid, iprot, oprot):
        args = getColumns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getColumns_result()
        try:
            result.success = self._handler.getColumns(args.sessionId, args.schema, args.table)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getColumns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateUsers(self, seqid, iprot, oprot):
        args = updateUsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateUsers_result()
        try:
            self._handler.updateUsers(args.userInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except QueryProcessingException as error1:
            msg_type = TMessageType.REPLY
            result.error1 = error1
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateUsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setProps(self, seqid, iprot, oprot):
        args = setProps_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setProps_result()
        try:
            self._handler.setProps(args.sessionId, args.propMap)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccessDeniedException as error2:
            msg_type = TMessageType.REPLY
            result.error2 = error2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setProps", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class clear_args(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 2)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_args)
clear_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'queryId', 'UTF8', None, ),  # 2
)


class clear_result(object):
    """
    Attributes:
     - error1
     - error2

    """


    def __init__(self, error1=None, error2=None,):
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_result')
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_result)
clear_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class cancelQuery_args(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelQuery_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 2)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelQuery_args)
cancelQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'queryId', 'UTF8', None, ),  # 2
)


class cancelQuery_result(object):
    """
    Attributes:
     - error1
     - error2

    """


    def __init__(self, error1=None, error2=None,):
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelQuery_result')
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelQuery_result)
cancelQuery_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class explain_args(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('explain_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 2)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(explain_args)
explain_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'queryId', 'UTF8', None, ),  # 2
)


class explain_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('explain_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(explain_result)
explain_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class dryRun_args(object):
    """
    Attributes:
     - sessionId
     - sSchema
     - sQueryString

    """


    def __init__(self, sessionId=None, sSchema=None, sQueryString=None,):
        self.sessionId = sessionId
        self.sSchema = sSchema
        self.sQueryString = sQueryString

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sSchema = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.sQueryString = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dryRun_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.sSchema is not None:
            oprot.writeFieldBegin('sSchema', TType.STRING, 2)
            oprot.writeString(self.sSchema.encode('utf-8') if sys.version_info[0] == 2 else self.sSchema)
            oprot.writeFieldEnd()
        if self.sQueryString is not None:
            oprot.writeFieldBegin('sQueryString', TType.STRING, 3)
            oprot.writeString(self.sQueryString.encode('utf-8') if sys.version_info[0] == 2 else self.sQueryString)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dryRun_args)
dryRun_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sSchema', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'sQueryString', 'UTF8', None, ),  # 3
)


class dryRun_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dryRun_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dryRun_result)
dryRun_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class explainAnalyze_args(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('explainAnalyze_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 2)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(explainAnalyze_args)
explainAnalyze_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'queryId', 'UTF8', None, ),  # 2
)


class explainAnalyze_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('explainAnalyze_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(explainAnalyze_result)
explainAnalyze_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class prepareStatement_args(object):
    """
    Attributes:
     - sessionId
     - sSchemaName
     - query

    """


    def __init__(self, sessionId=None, sSchemaName=None, query=None,):
        self.sessionId = sessionId
        self.sSchemaName = sSchemaName
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sSchemaName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareStatement_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.sSchemaName is not None:
            oprot.writeFieldBegin('sSchemaName', TType.STRING, 2)
            oprot.writeString(self.sSchemaName.encode('utf-8') if sys.version_info[0] == 2 else self.sSchemaName)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 3)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareStatement_args)
prepareStatement_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sSchemaName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'query', 'UTF8', None, ),  # 3
)


class prepareStatement_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('prepareStatement_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(prepareStatement_result)
prepareStatement_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class executeStatement_args(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeStatement_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 2)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeStatement_args)
executeStatement_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'queryId', 'UTF8', None, ),  # 2
)


class executeStatement_result(object):
    """
    Attributes:
     - error1
     - error2

    """


    def __init__(self, error1=None, error2=None,):
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeStatement_result')
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeStatement_result)
executeStatement_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class getNextResultRow_args(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNextResultRow_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 2)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNextResultRow_args)
getNextResultRow_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'queryId', 'UTF8', None, ),  # 2
)


class getNextResultRow_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNextResultRow_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNextResultRow_result)
getNextResultRow_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class getNextResultBatch_args(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNextResultBatch_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 2)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNextResultBatch_args)
getNextResultBatch_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'queryId', 'UTF8', None, ),  # 2
)


class getNextResultBatch_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNextResultBatch_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNextResultBatch_result)
getNextResultBatch_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class getResultMetadata_args(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.queryId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResultMetadata_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRING, 2)
            oprot.writeString(self.queryId.encode('utf-8') if sys.version_info[0] == 2 else self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResultMetadata_args)
getResultMetadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'queryId', 'UTF8', None, ),  # 2
)


class getResultMetadata_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getResultMetadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getResultMetadata_result)
getResultMetadata_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class authenticate_args(object):
    """
    Attributes:
     - user
     - password

    """


    def __init__(self, user=None, password=None,):
        self.user = user
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticate_args')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 1)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 2)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticate_args)
authenticate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'user', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'password', 'UTF8', None, ),  # 2
)


class authenticate_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticate_result)
authenticate_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [AccessDeniedException, None], None, ),  # 1
)


class getTables_args(object):
    """
    Attributes:
     - sessionId
     - schema

    """


    def __init__(self, sessionId=None, schema=None,):
        self.sessionId = sessionId
        self.schema = schema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.schema = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTables_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.STRING, 2)
            oprot.writeString(self.schema.encode('utf-8') if sys.version_info[0] == 2 else self.schema)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTables_args)
getTables_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'schema', 'UTF8', None, ),  # 2
)


class getTables_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTables_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter13 in self.success:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTables_result)
getTables_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class getSchemaNames_args(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSchemaNames_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSchemaNames_args)
getSchemaNames_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
)


class getSchemaNames_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSchemaNames_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter20 in self.success:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSchemaNames_result)
getSchemaNames_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class getColumns_args(object):
    """
    Attributes:
     - sessionId
     - schema
     - table

    """


    def __init__(self, sessionId=None, schema=None, table=None,):
        self.sessionId = sessionId
        self.schema = schema
        self.table = table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.schema = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getColumns_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.STRING, 2)
            oprot.writeString(self.schema.encode('utf-8') if sys.version_info[0] == 2 else self.schema)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 3)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getColumns_args)
getColumns_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'schema', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
)


class getColumns_result(object):
    """
    Attributes:
     - success
     - error1
     - error2

    """


    def __init__(self, success=None, error1=None, error2=None,):
        self.success = success
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = TFieldInfo()
                        _elem26.read(iprot)
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getColumns_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter27 in self.success:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getColumns_result)
getColumns_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TFieldInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class updateUsers_args(object):
    """
    Attributes:
     - userInfo

    """


    def __init__(self, userInfo=None,):
        self.userInfo = userInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userInfo = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateUsers_args')
        if self.userInfo is not None:
            oprot.writeFieldBegin('userInfo', TType.STRING, 1)
            oprot.writeBinary(self.userInfo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateUsers_args)
updateUsers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userInfo', 'BINARY', None, ),  # 1
)


class updateUsers_result(object):
    """
    Attributes:
     - error1
     - error2

    """


    def __init__(self, error1=None, error2=None,):
        self.error1 = error1
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error1 = QueryProcessingException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateUsers_result')
        if self.error1 is not None:
            oprot.writeFieldBegin('error1', TType.STRUCT, 1)
            self.error1.write(oprot)
            oprot.writeFieldEnd()
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 2)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateUsers_result)
updateUsers_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error1', [QueryProcessingException, None], None, ),  # 1
    (2, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 2
)


class setProps_args(object):
    """
    Attributes:
     - sessionId
     - propMap

    """


    def __init__(self, sessionId=None, propMap=None,):
        self.sessionId = sessionId
        self.propMap = propMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.propMap = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setProps_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.propMap is not None:
            oprot.writeFieldBegin('propMap', TType.STRING, 2)
            oprot.writeString(self.propMap.encode('utf-8') if sys.version_info[0] == 2 else self.propMap)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setProps_args)
setProps_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'propMap', 'UTF8', None, ),  # 2
)


class setProps_result(object):
    """
    Attributes:
     - error2

    """


    def __init__(self, error2=None,):
        self.error2 = error2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error2 = AccessDeniedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setProps_result')
        if self.error2 is not None:
            oprot.writeFieldBegin('error2', TType.STRUCT, 1)
            self.error2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setProps_result)
setProps_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error2', [AccessDeniedException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
